// LiuD syntax define
// LiuTaoTao github.com/Bookaa/LiuD

.name_prefix GFF

.string ANYLINE Name '[^}\n]+'
.string ANYNAME Name '[^({\n]+'
.string STR strtype1 '"(.|\n)*?"'
.string NUM_DOUBLE Double '\d*\.\d+(e(-)?\d+)?|\d+\.'

.set_linecomment ';'
.set_comment '\\\n'
.set_blockcomment '{-' '-}'

.syntax crlf


Module : blk* ENDMARKER$

blk :: commentblk | formu

commentblk : 'comment' '{' AnyLine* '}'

AnyLine : ANYLINE

formu : ANYNAME para? '{' AnyLine* '}'

formu_deep : ANYNAME para? '{' labelblk* '}'

para : '(' NAME ')'

labelblk :: init_blk | loop_blk | final_blk | default_blk | bailout_blk | anotherfmt

init_blk : 'init:' stmt*
loop_blk : 'loop:' stmt*
bailout_blk : 'bailout:' value
default_blk : 'default:' def_item*
final_blk : 'final:' stmt*
anotherfmt : stmtblk ':' stmtblk value

def_item :: dt_param | dt_func | general_param | general_func | xcenter | zcenter | wcenter | magnitude | xycenter | zwcenter | xzangle | ywangle | maxiter
    dt_param : AssignDT 'param' (Name0 | Name2) df_stmt* 'endparam'
    dt_func : AssignDT 'func' NAME df_stmt* 'endfunc'
    general_func : 'func' NAME df_stmt* 'endfunc'
    general_param : 'param' NAME df_stmt* 'endparam'
    xcenter : 'xcenter' '=' num22
    zcenter : 'zcenter' '=' num22
    wcenter : 'wcenter' '=' num22
    xycenter : 'xycenter' '=' Num_Complex
    zwcenter : 'zwcenter' '=' Num_Complex
    xzangle : 'xzangle' '=' num22
    ywangle : 'ywangle' '=' num22
    magnitude : 'magnitude' '=' num22
    maxiter : 'maxiter' '=' NUMBER_INT

    df_stmt :: df_caption | df_title | df_default | df_hint | df_enum | df_argtype
    df_title : 'title' '=' STR
    df_caption : 'caption' '=' STR
    df_default : 'default' '=' df_value
    df_hint : 'hint' '=' STR
    df_value :: funccall | Name1 | Name2 | Name0 | Number00 | Number01 | String | Num_Complex | Num_Hyper
    df_enum : 'enum' '=' STR*
	df_argtype : 'argtype' '=' AssignDT

stmt_1 :: assign | assign_complex | declare | if_stmt | while_stmt
stmt : stmt_1 ','?


AssignDT : ('float' | 'color' | 'complex' | 'int' | 'bool' | 'hyper')$
assign : AssignDT? nameq+ value
    nameq : (Name0|Name1) '='
assign_complex : (dest_real | dest_imag) '=' value
    dest_real : 'real' '(' Name0 ')'
    dest_imag : 'imag' '(' Name0 ')'
declare : AssignDT Name0
if_stmt : 'if' value stmtblk elseifblk* elseblk? 'endif'
while_stmt : 'while' value stmtblk 'endwhile'
elseifblk : 'elseif' value stmtblk
elseblk : 'else' stmtblk

stmtblk : stmt*

String : STR
Numi : NUMBER_INT
NegNumi : '-' NUMBER_INT
Number01 :: Numi | NegNumi
Number : NUM_DOUBLE
NegNumber : '-' NUM_DOUBLE
Number00 :: Number | NegNumber
Num_Complex : '(' value ',' value ')'
Num_Hyper : '(' value ',' value ',' value ',' value ')'
num22 :: Number00 | Number01
bool_value : ('false' | 'true')$
not_value : '!' value1
value0 :: bool_value | Name1 | Name2 | Name0 | Number00 | Number01 | String | Num_Complex | Num_Hyper | not_value
value1 :: funccall | value0 | EnclosedValue | AbsSigned
value2 : value1 ^- ('^' ('*'|'/') ('+'|'-') '%' ('>='|'>'|'<='|'<'|'==') ('||'|'&&'))

value :: neg_value | value2

neg_value : '-' value2

EnclosedValue : '(' value ')'
AbsSigned : '|' value '|'

funccall : value0 '(' callparam? ')'
callparam : value ^+ ','
Name0 : NAME
Name1 : '#' - NAME
Name2 : '@' - NAME

Output Rules {
    Module : (x NL)*
    stmt : x
    commentblk : 'comment {' NL (x NL)* '}'
    AnyLine : x
    para : '(' x ')'
    formu : x x? '{' NL (x NL)* '}'
    formu_deep : x x? '{' NL (x NL)* '}'

    Name1 : '#' - x
    Name2 : '@' - x
    init_blk : 'init:' NL x*
    loop_blk : 'loop:' NL x*
    bailout_blk : 'bailout:' NL x
    default_blk : 'default:' NL (x NL)*
    final_blk : 'final:' NL x*
    anotherfmt : x ':' NL x x
    assign : x? x* x
    assign_complex : x '=' x
    dest_real : 'real(' x ')'
    dest_imag : 'imag(' x ')'
    nameq : x '='
    declare : x x
    value2 : x x x
    neg_value : '-' - x
    String : x
    Name0 : x
    Number : x
    NegNumber : '-' - x
    Numi : x
    NegNumi : '-' - x
    Num_Complex : '(' x ',' x ')'
    Num_Hyper : '(' x ',' x ',' x ',' x ')'
    bool_value : x
    not_value : '!' x
    funccall : x '(' x? ')'
    callparam : x ^* ','
    dt_param : x 'param' x NL (x NL)* 'endparam'
    dt_func : x 'func' x NL (x NL)* 'endfunc'
    general_param : 'param' x x* 'endparam'
    general_func : 'func' x x* 'endfunc'
    EnclosedValue : '(' x ')'
    AbsSigned : '|' x '|'
    if_stmt : 'if' x NL x x* x? NL 'endif'
    while_stmt : 'while' x NL x 'endwhile'
    elseifblk : 'elseif' x NL x
    elseblk : 'else' NL x
    stmtblk : (x NL)*
    AssignDT : x
    df_enum : 'enum =' x*
    df_title : 'title =' x
    df_caption : 'caption =' x
    df_default : 'default =' x
    df_hint : 'hint =' x
	df_argtype : 'argtype =' x
    xcenter : 'xcenter =' x
    zcenter : 'zcenter =' x
    wcenter : 'wcenter =' x
    magnitude : 'magnitude =' x
    xycenter : 'xycenter =' x
    zwcenter : 'zwcenter =' x
    xzangle : 'xzangle =' x
    ywangle : 'ywangle =' x
    maxiter : 'maxiter =' x
}

Sample Text = $liud$

Barnsley Type 3 {
; From Michael Barnsley's book Fractals Everywhere, via Fractint
init:
	z = #zwpixel
loop:
	float x2 = real(z) * real(z)
	float y2 = imag(z) * imag(z)
	float xy = real(z) * imag(z)

	if(real(z) > 0)
		z = (x2 - y2 - 1.0, xy * 2.0)
	else
		z = (x2 - y2 - 1.0 + real(#pixel) * real(z), \
		     xy * 2.0 + imag(#pixel) * real(z))
	endif
bailout:
	@bailfunc(z) < @bailout
default:
float param bailout
	default = 4.0
endparam
float func bailfunc
	default = cmag
endfunc
}

$duil$

/*
Sample Text = $liud$

comment {

Standard Gnofract4D coloring algorithms

}

default (OUTSIDE){
; the default is just to use the iteration count
final:
#index = #numiter / 256.0
}

basins {
final:
#index = (#fate * 1.0/@nbasins)
if @mode == "basin + iterations"
	#index = #index + (#numiter / 256.0) % @nbasins
elseif @mode == "basin + potential"
    float ed = @bailout/(|z| + 1.0e-9)
	#index = #index + ((#numiter + ed)/ 256.0) % @nbasins
endif
default:
int param nbasins
	default = 3
endparam
int param mode
	enum = "basin" "basin + iterations" "basin + potential"
	default = "basin + iterations"
endparam
float param bailout
	default = 4.0
endparam
}

direct_basins_2 {
final:
float ratio = log(#numiter+1)/log(#maxiter+1)
color c = gradient(#fate/float(@nbasins))
#color = blend(c,@background,ratio)

default:
color param background
	default = rgb(1.0,1.0,1.0)
endparam
int param nbasins
    default = 3
endparam
}


direct_basins {
final:
float ratio = log(#numiter+1)/log(#maxiter+1)
if #fate == 0
	#color = blend(@basin1,@background,ratio)
elseif #fate == 1
	#color = blend(@basin2,@background,ratio)
elseif #fate == 2
	#color = blend(@basin3,@background,ratio)
else
	#color = blend(@basin4,@background,ratio)
endif

default:
color param basin1
	default = rgb(0.464, 0.597, 0.664)
endparam
color param basin2
	default = rgb(0.199, 0.332, 0.398)
endparam
color param basin3
	default = rgb(0.867, 0.851, 0.789)
endparam
color param basin4
	default = rgb(0.551, 0.531, 0.438)
endparam
color param background
	default = rgb(1.0,1.0,1.0)
endparam
}

zero (BOTH) {
final:
#solid = true
}

continuous_potential {
final:
float ed = @bailout/(|z| + 1.0e-9)
#index = (#numiter + ed) / 256.0
default:
float param bailout
	default = 4.0
endparam
}

external_angle {
final:
float angle = atan2(z)
if angle < 0.0
	angle = 2.0 * #pi + angle
endif
#index = angle / (2.0 * #pi)
}

biomorph {
final:
if |real(z)| < @zlimit || |imag(z)| < @zlimit
	#solid = true
else
	float ed = @bailout/(|z| + 1.0e-9)
	#index = (#numiter + ed) / 256.0
endif
default:
float param zlimit
	default = 2.0
endparam
float param bailout
	default = 4.0
endparam
}

decomposition {
final:
float quadrant = 0.0;
if(real(z) < 0.0)
	quadrant = quadrant + 0.25
endif
if(imag(z) < 0.0)
	quadrant = quadrant + 0.5
endif
#index = quadrant
}

ejection_distance {
final:
float ed = @bailout/(|z| + 1.0e-9)
#index = ed
default:
float param bailout
	default = 4.0
endparam
}

rgb {
; for backwards compatibility with 1.x versions of Gnofract 4D.
; also rather cool looking
init:
	color ccol = @col * 10.0
	ccol = rgb(red(@col) + 1.0, green(@col) + 1.0, blue(@col) + 1.0)
final:
	float dist = #numiter / 256.0
	ccol = ccol * dist
	#color = rgb(red(ccol) % 256, green(ccol) % 256, blue(ccol) % 256)
default:
color param col
	default = rgb(1.0,0.0,0.0)
endparam
}

rgb_parts {
; direct coloring algorithm which sets hsl separately
;
final:
	; hue = angle
	float angle = atan2(z)
	if angle < 0.0
		angle = 2.0 * #pi + angle
	endif
	; convert to 0..6
	float h = angle * 6.0 / (2.0 * #pi)

	; saturation =ejection distance
	float s = @bailout/(|z| + 1.0e-9)

	; luminosity = #numiter
	float l = ((#numiter / #maxiter) - 1.0)*2.0

	#color = hsl(h,s,l)
default:
float param bailout
	default = 4.0
endparam
}

Angles {
; delta total, total, min, delta min, max, delta max, avg, delta avg
; iter @ min, iter @ max, iter @ delta min, iter @ delta max
init:
float angle = 0.0
complex lastz = (0,0)
float temp_angle
int itermin = 0
int itermax = 0
if @angle_type == "delta min" || @angle_type == "min" || @angle_type == "iter @ min"
    angle = #pi
endif
loop:
if @angle_type == "delta total"
    angle = angle + abs(atan2(z-lastz))
elseif @angle_type == "delta max"
    temp_angle = abs(atan2(z-lastz))
    if temp_angle > angle
	angle = temp_angle
    endif
elseif @angle_type == "delta min"
    temp_angle = abs(atan2(z-lastz))
    if temp_angle < angle
	angle = temp_angle
    endif
elseif @angle_type == "min" || @angle_type == "iter @ min"
    temp_angle = abs(atan2(z))
    if temp_angle < angle
	angle = temp_angle
	itermin = #numiter
    endif
elseif @angle_type == "max" || @angle_type == "iter @ max"
    temp_angle = abs(atan2(z))
    if temp_angle > angle
	angle = temp_angle
	itermax = #numiter
    endif
elseif @angle_type == "total"
    angle = angle + abs(atan2(z))
endif
lastz = z
final:
if @angle_type == "iter @ min"
    #index = itermin/256.0
elseif @angle_type == "iter @ max"
    #index = itermax/256.0
else
    #index = angle/#pi
endif
default:
param angle_type
	default = 0
	enum = "delta total" "delta max" "delta min" "min" "max" "total" "iter @ min" "iter @ max"
endparam
}

Hot And Cold {
; 2 colors - on each orbit, the closer we are to 0, the more hot,
; the closer we are to bailout, the more cold. Compute an average over
; all iterations

init:
float dist=0.0
int closecalls=0
int farcalls=0
loop:
dist = |z|
if dist < @closedist
   closecalls = closecalls + 1
elseif @bailout - dist < @fardist
   farcalls = farcalls + 1
endif
final:
#color = @hotcolor * (closecalls/#numiter) + @coldcolor * (farcalls/#numiter)
default:
float param fardist
	default = 1.0
endparam
float param closedist
	default = 0.2
endparam
float param bailout
	default = 4.0
endparam
color param hotcolor
	default = rgb(0.97, 0.43, 0.01)
endparam
color param coldcolor
	default = rgb(0.49, 0.79, 0.96)
endparam
}

Hot And Cold Gradient {
; On each orbit, the closer we are to 0, the lower in the gradient we are.
; the closer we are to bailout, the higher.

init:
float dist=0.0
color thecolor = @startcolor
loop:
dist = |z|/@bailout
color thiscolor = gradient(dist)
thecolor = compose(thecolor, blend(thiscolor, @mergemode(thecolor, thiscolor), 1.0), @mergeopacity)

final:
#color = thecolor
default:
float param bailout
	default = 4.0
endparam
color param startcolor
	default = rgb(1.0, 1.0, 1.0)
endparam

color func mergemode
  caption = "Color Merge"
  default = mergenormal()
  hint = "This chooses the merge mode used to blend colors at each iteration."
endfunc

param mergeopacity
  caption = "Trap Merge Opacity"
  default = 0.2
  hint = "Sets the opacity of each trap shape. Even if you set this value to 1 \
        (forcing all traps to be fully opaque) you can still control opacity \
        using the alpha channel in the gradient."
endparam

}

Direct Signs {
; based on when sign changes occur for x or y parts of z
init:
color thecolor = @startcolor
color thiscolor
complex lastz = (-1,-1)

loop:
bool update_color = false
float offset = 0.0
float dist = 0.0
if @xpos && real(z) > 0 && real(lastz) < 0
   dist = | real(z) - real(lastz)|
   update_color = true
endif
if @xneg && real(z) < 0 && real(lastz) > 0
   dist = | real(z) - real(lastz)|
   offset = 0.25
   update_color = true
endif
if @ypos && imag(z) > 0 && imag(lastz) < 0
   dist = | imag(z) - imag(lastz)|
   thiscolor = gradient(#numiter/#maxiter)
   offset = 0.5
   update_color = true
endif
if @yneg && imag(z) < 0 && imag(lastz) > 0
   dist = | imag(z) - imag(lastz)|
   thiscolor = gradient(#numiter/#maxiter)
   offset = 0.75
   update_color = true
endif

if ! @offset
	offset = 0.0
endif
if update_color
   float pos
   if @colortype == "iter"
	pos = (#numiter/#maxiter + offset) % 1.0
   elseif @colortype == "distance"
        pos = (dist/@bailout * 2.0 + offset) % 1.0
   endif
   thiscolor = gradient(pos)
   thecolor = compose(thecolor, blend(thiscolor, @mergemode(thecolor, thiscolor), 1.0), @mergeopacity)
endif
lastz = z

final:
#color = thecolor
default:
color param startcolor
	default = rgb(1.0, 1.0, 1.0)
endparam

param colortype
	enum = "iter" "distance"
endparam

float param bailout
	default = 4.0
endparam

bool param xpos
	default = true
	hint = "Capture color when x becomes positive"
endparam

bool param xneg
	default = true
	hint = "Capture color when x becomes negative"
endparam

bool param ypos
	default = true
	hint = "Capture color when y becomes positive"
endparam

bool param yneg
	default = true
	hint = "Capture color when y becomes negative"
endparam

bool param offset
	default = false
endparam

color func mergemode
  caption = "Color Merge"
  default = mergenormal()
  hint = "This chooses the merge mode used to blend colors at each iteration."
endfunc

param mergeopacity
  caption = "Trap Merge Opacity"
  default = 0.2
  hint = "Sets the opacity of each trap shape. Even if you set this value to 1 \
        (forcing all traps to be fully opaque) you can still control opacity \
        using the alpha channel in the gradient."
endparam
}

Signs {
; based on when sign changes occur for x or y parts of z
init:
complex lastz = (-1,-1)

int min_iter_x = 0
int max_iter_x = 0
int min_iter_y = 0
int max_iter_y = 0

loop:
if real(z) * real(lastz) < 0
   max_iter_x = #numiter
endif
if imag(z) * imag(lastz) < 0
   max_iter_y = #numiter
endif
lastz = z
final:
if @sign_type == "x iter"
    #index = max_iter_x/256.0
elseif @sign_type == "y iter"
    #index = max_iter_y/256.0
endif
default:
param sign_type
	default = 0
	enum = "x iter" "y iter"
endparam
}

continuous_decomposition {
final:
float quadrant = 0.0;
if(real(z) < 0.0)
	quadrant = quadrant + 0.25
endif
if(imag(z) < 0.0)
	quadrant = quadrant + 0.5
endif
float ed = @bailout/(|z| + 1.0e-9)
#index = (#numiter + ed) / 256.0 + @quadfactor * quadrant
default:
float param bailout
	default = 4.0
endparam
float param @quadfactor
      default = 1.0
endparam
}

$duil$
*/