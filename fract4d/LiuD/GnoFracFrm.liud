// LiuD syntax define
// LiuTaoTao github.com/Bookaa/LiuD

.name_prefix GFF

.string ANYLINE Name '[^}\]\n]+'
.string ANYNAME Name '[^({\n]+'
.string STR strtype1 '"((?:.|\n)*?)"'
.string NUM_DOUBLE Double '[-]?\d*\.\d+(e(-)?\d+)?|\d+\.'
.string HEXNUM Name '[0-9a-fA-F]+'
.string FILENAME Name '[A-Za-z_][^}\]\n]*'

.set_linecomment ';'
.set_comment '\\\n'
.set_blockcomment '{-' '-}'

.syntax crlf

FCT_File : 'gnofract4d parameter file' fctf_item* ENDMARKER$
    fctf_item :: NameEquValue | fctf_section
    NameEquValue : Name0 '=' value0
    fctf_section : '[' NAME ']' fctfs_item* '[endsection]'
    fctfs_item :: fctfs_formula | gradient | solids | colordata | ExtEqu | NameEquValue2 | NameEquValue
    gradient : ('@_gradient' | 'gradient')$ '=' '[' AnyLine* ']'
    solids : 'solids' '=' '[' hex* ']'
    NameEquValue2 : Name2 '=' value0
    colordata : 'colordata' '=' HEXNUM
    fctfs_formula : 'formula' '=' '[' formu ']'
    hex : HEXNUM
    ExtEqu : ('formulafile' | 'function')$ '=' FILENAME

Module : blk* ENDMARKER$

blk :: commentblk | formu

commentblk : 'comment' '{' AnyLine* '}'

AnyLine : ANYLINE

formu : ANYNAME para? '{' AnyLine* '}'

formu_deep : ANYNAME para? '{' labelblk* '}'

para : '(' NAME ')'

labelblk :: init_blk | loop_blk | final_blk | default_blk | bailout_blk | anotherfmt

init_blk : 'init:' stmt*
loop_blk : 'loop:' stmt*
bailout_blk : 'bailout:' value
default_blk : 'default:' def_item*
final_blk : 'final:' stmt*
anotherfmt : stmtblk ':' stmtblk value

def_item :: dt_param | dt_func | general_param | general_func | xcenter | zcenter | wcenter | magnitude | xycenter | zwcenter | xzangle | ywangle | maxiter
    dt_param : AssignDT 'param' (Name0 | Name2) df_stmt* 'endparam'
    dt_func : AssignDT 'func' NAME df_stmt* 'endfunc'
    general_func : 'func' NAME df_stmt* 'endfunc'
    general_param : 'param' NAME df_stmt* 'endparam'
    xcenter : 'xcenter' '=' num22
    zcenter : 'zcenter' '=' num22
    wcenter : 'wcenter' '=' num22
    xycenter : 'xycenter' '=' Num_Complex
    zwcenter : 'zwcenter' '=' Num_Complex
    xzangle : 'xzangle' '=' num22
    ywangle : 'ywangle' '=' num22
    magnitude : 'magnitude' '=' num22
    maxiter : 'maxiter' '=' NUMBER_INT

    df_stmt :: df_caption | df_title | df_default | df_hint | df_enum | df_argtype
    df_title : 'title' '=' STR
    df_caption : 'caption' '=' STR
    df_default : 'default' '=' df_value
    df_hint : 'hint' '=' STR
    df_value :: funccall | Name1 | Name2 | Name0 | Number00 | Number01 | String | Num_Complex | Num_Hyper
    df_enum : 'enum' '=' STR*
	df_argtype : 'argtype' '=' AssignDT

stmt_1 :: assign | assign_complex | declare | if_stmt | while_stmt
stmt : stmt_1 ','?


AssignDT : ('float' | 'color' | 'complex' | 'int' | 'bool' | 'hyper')$
assign : AssignDT? nameq+ value
    nameq : (Name0|Name1) '='
assign_complex : (dest_real | dest_imag) '=' value
    dest_real : 'real' '(' Name0 ')'
    dest_imag : 'imag' '(' Name0 ')'
declare : AssignDT Name0
if_stmt : 'if' value stmtblk elseifblk* elseblk? 'endif'
while_stmt : 'while' value stmtblk 'endwhile'
elseifblk : 'elseif' value stmtblk
elseblk : 'else' stmtblk

stmtblk : stmt*

String : STR
Numi : NUMBER_INT
NegNumi : '-' NUMBER_INT
Number01 :: Numi | NegNumi
Number : NUM_DOUBLE
Number00 :: Number
Num_Complex : '(' value ',' value ')'
Num_Hyper : '(' value ',' value ',' value ',' value ')'
num22 :: Number00 | Number01
bool_value : ('false' | 'true')$
not_value : '!' value1
value0 :: bool_value | Name1 | Name2 | Name0 | Number00 | Number01 | String | Num_Complex | Num_Hyper | not_value
value1 :: funccall | value0 | EnclosedValue | AbsSigned
value2 : value1 ^- ('^' ('*'|'/') '%' ('+'|'-') ('>='|'>'|'<='|'<'|'==') ('||'|'&&'))

value :: value2 | neg_value

neg_value : '-' value2

EnclosedValue : '(' value ')'
AbsSigned : '|' value '|'

funccall : value0 '(' callparam? ')'
callparam : value ^+ ','
Name0 : NAME
Name1 : '#' - NAME
Name2 : '@' - NAME

Output Rules {
    Module : (x NL)*
    stmt : x
    commentblk : 'comment {' NL (x NL)* '}'
    AnyLine : x
    para : '(' x ')'
    formu : x x? '{' NL (x NL)* '}'
    formu_deep : x x? '{' NL (x NL)* '}'

    Name1 : '#' - x
    Name2 : '@' - x
    init_blk : 'init:' +ident (x NL)* -ident
    loop_blk : 'loop:' +ident (x NL)* -ident
    bailout_blk : 'bailout:' NL x
    default_blk : 'default:' +ident (x NL)* -ident
    final_blk : 'final:' +ident (x NL)* -ident
    anotherfmt : x ':' NL x x
    assign : x? x* x
    assign_complex : x '=' x
    dest_real : 'real(' x ')'
    dest_imag : 'imag(' x ')'
    nameq : x '='
    declare : x x
    value2 : x x x
    neg_value : '-' - x
    String : x
    Name0 : x
    Number : x
    Numi : x
    NegNumi : '-' - x
    Num_Complex : '(' x ',' x ')'
    Num_Hyper : '(' x ',' x ',' x ',' x ')'
    bool_value : x
    not_value : '!' x
    funccall : x '(' x? ')'
    callparam : x ^* ','
    dt_param : x 'param' x NL +ident (x NL)* -ident 'endparam'
    dt_func : x 'func' x NL (x NL)* 'endfunc'
    general_param : 'param' x +ident (x NL)* -ident 'endparam'
    general_func : 'func' x x* 'endfunc'
    EnclosedValue : '(' x ')'
    AbsSigned : '|' x '|'
    if_stmt : 'if' x +ident x -ident x* x? NL 'endif'
    while_stmt : 'while' x NL x 'endwhile'
    elseifblk : 'elseif' x +ident x -ident
    elseblk : 'else' +ident x -ident
    stmtblk : (x NL)*
    AssignDT : x
    df_enum : 'enum =' x*
    df_title : 'title =' x
    df_caption : 'caption =' x
    df_default : 'default =' x
    df_hint : 'hint =' x
	df_argtype : 'argtype =' x
    xcenter : 'xcenter =' x
    zcenter : 'zcenter =' x
    wcenter : 'wcenter =' x
    magnitude : 'magnitude =' x
    xycenter : 'xycenter =' x
    zwcenter : 'zwcenter =' x
    xzangle : 'xzangle =' x
    ywangle : 'ywangle =' x
    maxiter : 'maxiter =' x
    FCT_File : 'gnofract4d parameter file' (x NL)*
    NameEquValue : x '=' x
    NameEquValue2 : x '=' x
    fctf_section : '[' x ']' NL (x NL)* '[endsection]'
    gradient : x '=' '[' (x NL)* ']'
    solids : 'solids' '=' '[' (x NL)* ']'
    fctfs_formula : 'formula' '=' '[' x NL ']'
    hex : x
    ExtEqu : x '=' x
    colordata : 'colordata' '=' x
}

Sample Text = $liud$

Angles {
; delta total, total, min, delta min, max, delta max, avg, delta avg
; iter @ min, iter @ max, iter @ delta min, iter @ delta max
init:
float angle = 0.0
complex lastz = (0,0)
float temp_angle
int itermin = 0
int itermax = 0
if @angle_type == "delta min" || @angle_type == "min" || @angle_type == "iter @ min"
    angle = #pi
endif
loop:
if @angle_type == "delta total"
    angle = angle + abs(atan2(z-lastz))
elseif @angle_type == "delta max"
    temp_angle = abs(atan2(z-lastz))
    if temp_angle > angle
	angle = temp_angle
    endif
elseif @angle_type == "delta min"
    temp_angle = abs(atan2(z-lastz))
    if temp_angle < angle
	angle = temp_angle
    endif
elseif @angle_type == "min" || @angle_type == "iter @ min"
    temp_angle = abs(atan2(z))
    if temp_angle < angle
	angle = temp_angle
	itermin = #numiter
    endif
elseif @angle_type == "max" || @angle_type == "iter @ max"
    temp_angle = abs(atan2(z))
    if temp_angle > angle
	angle = temp_angle
	itermax = #numiter
    endif
elseif @angle_type == "total"
    angle = angle + abs(atan2(z))
endif
lastz = z
final:
if @angle_type == "iter @ min"
    #index = itermin/256.0
elseif @angle_type == "iter @ max"
    #index = itermax/256.0
else
    #index = angle/#pi
endif
default:
param angle_type
	default = 0
	enum = "delta total" "delta max" "delta min" "min" "max" "total" "iter @ min" "iter @ max"
endparam
}

$duil$
